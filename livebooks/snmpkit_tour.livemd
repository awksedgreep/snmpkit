# SnmpKit Interactive Tour 🚀

## Welcome to SnmpKit v0.3.0!

This interactive Livebook will take you on a comprehensive tour of SnmpKit's new **unified API**. We'll start by creating a simulated SNMP device and then demonstrate all the powerful features against our own simulation - no external network required!

**What you'll learn:**
- 🎯 **Unified API** - Clean, context-based modules
- 📡 **SNMP Operations** - get, walk, bulk, multi-target
- 📚 **MIB Management** - resolution, compilation, tree navigation
- 🧪 **Device Simulation** - realistic testing environments
- ⚡ **Advanced Features** - streaming, performance, analytics

Let's get started! 🚀

## Setup

First, let's install SnmpKit and configure our environment:

```elixir
Mix.install([
  {:snmpkit, "~> 0.3.0"}
])

# Configure logging for our tour
Logger.configure(level: :info)

# Import the unified API modules for convenience
alias SnmpKit.{SNMP, MIB, Sim}

IO.puts("🎉 SnmpKit v0.3.0 loaded successfully!")
IO.puts("📚 Ready to explore the unified API!")
```

## Chapter 1: Start Our Simulated Network 🖥️

Before we can demonstrate SNMP operations, let's create our own simulated network! This is one of SnmpKit's most powerful features - realistic device simulation for testing and development.

### Create a Cable Modem Simulation

```elixir
# First, let's load a cable modem profile
# This creates a realistic DOCSIS cable modem with hundreds of OIDs
{:ok, cable_modem_profile} = SnmpKit.SnmpSim.ProfileLoader.load_profile(
  :cable_modem,
  {:walk_file, "priv/walks/cable_modem.walk"}
)

# Start our simulated cable modem on port 1161
{:ok, cable_modem} = Sim.start_device(cable_modem_profile, [
  port: 1161,
  community: "public"
])

# Define our target for easy reference
cable_modem_target = "127.0.0.1:1161"

IO.puts("✅ Cable modem simulation started on #{cable_modem_target}")
IO.puts("🎯 Ready for SNMP operations!")
```

### Create a Router Simulation

Let's also create a router simulation to demonstrate multi-target operations:

```elixir
# Load and start a router simulation
{:ok, router_profile} = SnmpKit.SnmpSim.ProfileLoader.load_profile(
  :router,
  {:walk_file, "priv/walks/router.walk"}
)

{:ok, router} = Sim.start_device(router_profile, [
  port: 1162,
  community: "public"
])

router_target = "127.0.0.1:1162"

IO.puts("✅ Router simulation started on #{router_target}")
IO.puts("🌐 Now we have a complete simulated network!")
```

### Quick Connectivity Test

Let's verify our simulated devices are responding:

```elixir
# Test cable modem
case SNMP.get(cable_modem_target, "sysDescr.0") do
  {:ok, description} ->
    IO.puts("📡 Cable Modem: #{description}")
  {:error, reason} ->
    IO.puts("❌ Cable modem error: #{inspect(reason)}")
end

# Test router
case SNMP.get(router_target, "sysDescr.0") do
  {:ok, description} ->
    IO.puts("🔀 Router: #{description}")
  {:error, reason} ->
    IO.puts("❌ Router error: #{inspect(reason)}")
end

IO.puts("\n🎉 Both devices are responding! Let's explore the API...")
```

## Chapter 2: SnmpKit.SNMP - Protocol Operations 📡

Now let's explore the comprehensive SNMP operations available through `SnmpKit.SNMP`. All operations will work against our simulated devices!

### Basic GET Operations

```elixir
IO.puts("=== Basic SNMP GET Operations ===\n")

# Standard GET operation
{:ok, system_desc} = SNMP.get(cable_modem_target, "sysDescr.0")
IO.puts("System Description: #{system_desc}")

# GET with type information
{:ok, {oid, type, value}} = SNMP.get_with_type(cable_modem_target, "sysUpTime.0")
IO.puts("System Uptime: #{value} (#{type}) at OID #{Enum.join(oid, ".")}")

# GET with pretty formatting
{:ok, formatted_uptime} = SNMP.get_pretty(cable_modem_target, "sysUpTime.0")
IO.puts("Formatted Uptime: #{formatted_uptime}")

# GET system contact
{:ok, contact} = SNMP.get(cable_modem_target, "sysContact.0")
IO.puts("System Contact: #{contact}")
```

### WALK Operations

WALK operations traverse the SNMP tree to get multiple related values:

```elixir
IO.puts("\n=== SNMP WALK Operations ===\n")

# Walk the system group
{:ok, system_info} = SNMP.walk(cable_modem_target, "system")
IO.puts("System group contains #{length(system_info)} objects:")

# Display first few system objects
system_info
|> Enum.take(5)
|> Enum.each(fn {oid, value} ->
  IO.puts("  #{oid} = #{inspect(value)}")
end)

# Walk with pretty formatting
{:ok, pretty_system} = SNMP.walk_pretty(cable_modem_target, "system")
IO.puts("\nPretty formatted system info:")
pretty_system
|> Enum.take(3)
|> Enum.each(fn {name, value} ->
  IO.puts("  #{name}: #{value}")
end)
```

### Interface Information

Let's explore interface data, which is crucial for network monitoring:

```elixir
IO.puts("\n=== Interface Information ===\n")

# Get interface count
{:ok, if_count} = SNMP.get(cable_modem_target, "ifNumber.0")
IO.puts("Number of interfaces: #{if_count}")

# Get interface table (structured data)
{:ok, if_table} = SNMP.get_table(cable_modem_target, "ifTable")
IO.puts("Interface table has #{length(if_table)} entries")

# Display interface information
if_table
|> Enum.take(2)
|> Enum.with_index(1)
|> Enum.each(fn {interface, index} ->
  IO.puts("\nInterface #{index}:")
  interface
  |> Enum.take(5)
  |> Enum.each(fn {oid, value} ->
    IO.puts("  #{oid}: #{value}")
  end)
end)
```

### Bulk Operations for Efficiency

For large amounts of data, bulk operations are much more efficient:

```elixir
IO.puts("\n=== Bulk Operations ===\n")

# Standard bulk walk
{:ok, bulk_results} = SNMP.bulk_walk(cable_modem_target, "interfaces")
IO.puts("Bulk walk of interfaces returned #{length(bulk_results)} objects")

# Adaptive bulk walk (auto-optimizes performance)
{:ok, adaptive_results} = SNMP.adaptive_walk(cable_modem_target, "interfaces")
IO.puts("Adaptive walk returned #{length(adaptive_results)} objects")

# Get bulk with specific parameters
{:ok, bulk_specific} = SNMP.get_bulk(cable_modem_target, "interfaces", [
  max_repetitions: 5,
  timeout: 2000
])
IO.puts("Targeted bulk operation returned #{length(bulk_specific)} objects")

# Show some bulk results
bulk_results
|> Enum.take(3)
|> Enum.each(fn {oid, type, value} ->
  IO.puts("  #{oid} (#{type}): #{inspect(value)}")
end)
```

### Multi-Target Operations

One of SnmpKit's powerful features is querying multiple devices simultaneously:

```elixir
IO.puts("\n=== Multi-Target Operations ===\n")

# Query both devices for system information
multi_targets = [
  {cable_modem_target, "sysDescr.0"},
  {router_target, "sysDescr.0"},
  {cable_modem_target, "sysUpTime.0"},
  {router_target, "sysContact.0"}
]

{:ok, multi_results} = SNMP.get_multi(multi_targets)
IO.puts("Multi-target query results:")

multi_results
|> Enum.each(fn
  {:ok, {target, oid, value}} ->
    IO.puts("  ✅ #{target} #{oid}: #{value}")
  {:error, {target, oid, reason}} ->
    IO.puts("  ❌ #{target} #{oid}: #{inspect(reason)}")
end)

# Multi-target walk operations
walk_targets = [
  {cable_modem_target, "system"},
  {router_target, "system"}
]

{:ok, multi_walk_results} = SNMP.walk_multi(walk_targets)
IO.puts("\nMulti-target walk completed for #{length(multi_walk_results)} targets")
```

## Chapter 3: SnmpKit.MIB - MIB Management 📚

The MIB (Management Information Base) system is the heart of SNMP. It defines the structure and meaning of SNMP data. Let's explore SnmpKit's powerful MIB capabilities!

### OID Name Resolution

```elixir
IO.puts("=== MIB Name Resolution ===\n")

# Resolve common SNMP object names to OIDs
common_objects = [
  "sysDescr.0",
  "sysUpTime.0",
  "sysContact.0",
  "ifNumber.0",
  "ifDescr.1",
  "ifInOctets.1",
  "system",
  "interfaces"
]

IO.puts("Common SNMP objects and their OIDs:")
Enum.each(common_objects, fn name ->
  case MIB.resolve(name) do
    {:ok, oid} ->
      IO.puts("  #{name} → #{Enum.join(oid, ".")}")
    {:error, reason} ->
      IO.puts("  #{name} → Error: #{reason}")
  end
end)
```

### Reverse OID Lookup

```elixir
IO.puts("\n=== Reverse OID Lookup ===\n")

# Convert OIDs back to names
test_oids = [
  [1, 3, 6, 1, 2, 1, 1, 1, 0],
  [1, 3, 6, 1, 2, 1, 1, 3, 0],
  [1, 3, 6, 1, 2, 1, 2, 1, 0],
  [1, 3, 6, 1, 2, 1, 2, 2, 1, 2, 1]
]

IO.puts("OID to name resolution:")
Enum.each(test_oids, fn oid ->
  case MIB.reverse_lookup(oid) do
    {:ok, name} ->
      IO.puts("  #{Enum.join(oid, ".")} → #{name}")
    {:error, reason} ->
      IO.puts("  #{Enum.join(oid, ".")} → #{reason}")
  end
end)
```

### MIB Tree Navigation

```elixir
IO.puts("\n=== MIB Tree Navigation ===\n")

# Get children of the system group
{:ok, system_oid} = MIB.resolve("system")
{:ok, system_children} = MIB.children(system_oid)

IO.puts("System group (#{Enum.join(system_oid, ".")}) has #{length(system_children)} children:")
system_children
|> Enum.take(5)
|> Enum.each(fn child_oid ->
  case MIB.reverse_lookup(child_oid) do
    {:ok, name} ->
      IO.puts("  #{Enum.join(child_oid, ".")} (#{name})")
    {:error, _} ->
      IO.puts("  #{Enum.join(child_oid, ".")}")
  end
end)

# Get parent of a specific OID
{:ok, sys_descr_oid} = MIB.resolve("sysDescr.0")
{:ok, parent_oid} = MIB.parent(sys_descr_oid)
{:ok, parent_name} = MIB.reverse_lookup(parent_oid)
IO.puts("\nParent of sysDescr.0: #{Enum.join(parent_oid, ".")} (#{parent_name})")
```

### Integration: MIB + SNMP Operations

Let's combine MIB resolution with SNMP operations for powerful network monitoring:

```elixir
IO.puts("\n=== MIB + SNMP Integration ===\n")

# Define monitoring objects by name (more readable)
monitoring_objects = [
  "sysDescr.0",
  "sysUpTime.0",
  "sysContact.0",
  "ifNumber.0"
]

IO.puts("Network monitoring using named objects:")
Enum.each(monitoring_objects, fn object_name ->
  case MIB.resolve(object_name) do
    {:ok, oid} ->
      case SNMP.get(cable_modem_target, object_name) do
        {:ok, value} ->
          IO.puts("  ✅ #{object_name}: #{value}")
        {:error, reason} ->
          IO.puts("  ❌ #{object_name}: #{inspect(reason)}")
      end
    {:error, reason} ->
      IO.puts("  ❌ #{object_name}: MIB resolution failed - #{reason}")
  end
end)
```

### Enterprise MIB Support

SnmpKit includes support for enterprise-specific MIBs:

```elixir
IO.puts("\n=== Enterprise MIB Support ===\n")

# Try some enterprise-specific OIDs (these work with our simulated devices)
enterprise_objects = [
  "enterprises",
  "snmpV2",
  "mib-2"
]

IO.puts("Enterprise MIB objects:")
Enum.each(enterprise_objects, fn name ->
  case MIB.resolve(name) do
    {:ok, oid} ->
      IO.puts("  #{name} → #{Enum.join(oid, ".")}")
    {:error, reason} ->
      IO.puts("  #{name} → #{reason}")
  end
end)
```

## Chapter 4: Advanced SNMP Features ⚡

Let's explore some of SnmpKit's advanced features for high-performance and large-scale operations.

### Streaming Operations

For very large datasets, streaming prevents memory issues:

```elixir
IO.puts("=== Streaming Operations ===\n")

# Create a stream for large interface walks
interface_stream = SNMP.walk_stream(cable_modem_target, "interfaces")

# Process the stream efficiently
results = interface_stream
|> Stream.take(10)  # Just take first 10 for demo
|> Enum.to_list()

IO.puts("Streamed #{length(results)} interface objects:")
results
|> Enum.take(3)
|> Enum.each(fn {oid, value} ->
  IO.puts("  #{oid}: #{inspect(value)}")
end)

# Table streaming for structured data
table_stream = SNMP.table_stream(cable_modem_target, "ifTable")
table_results = table_stream |> Stream.take(5) |> Enum.to_list()
IO.puts("\nStreamed #{length(table_results)} table entries")
```

### Performance Analysis

SnmpKit includes tools for analyzing and optimizing SNMP performance:

```elixir
IO.puts("\n=== Performance Analysis ===\n")

# Benchmark a device's performance characteristics
{:ok, benchmark} = SNMP.benchmark_device(cable_modem_target, "system")
IO.puts("Device benchmark results:")
IO.puts("  Optimal bulk size: #{benchmark.optimal_bulk_size}")
IO.puts("  Average response time: #{benchmark.avg_response_time}ms")
IO.puts("  Success rate: #{benchmark.success_rate}%")

# Analyze table data for insights
{:ok, if_table} = SNMP.get_table(cable_modem_target, "ifTable")
{:ok, analysis} = SNMP.analyze_table(if_table)
IO.puts("\nInterface table analysis:")
IO.puts("  Completeness: #{analysis.completeness}%")
IO.puts("  Total entries: #{analysis.total_entries}")
```

### Async Operations

For non-blocking operations, use the async versions:

```elixir
IO.puts("\n=== Async Operations ===\n")

# Start multiple async operations
async_tasks = [
  SNMP.get_async(cable_modem_target, "sysDescr.0"),
  SNMP.get_async(router_target, "sysDescr.0"),
  SNMP.walk_async(cable_modem_target, "system"),
  SNMP.get_bulk_async(router_target, "interfaces")
]

# Wait for all to complete
results = Enum.map(async_tasks, &Task.await(&1, 5000))

IO.puts("Async operations completed:")
results
|> Enum.with_index()
|> Enum.each(fn {result, index} ->
  case result do
    {:ok, data} when is_list(data) ->
      IO.puts("  Task #{index + 1}: ✅ #{length(data)} items")
    {:ok, data} ->
      IO.puts("  Task #{index + 1}: ✅ #{inspect(data)}")
    {:error, reason} ->
      IO.puts("  Task #{index + 1}: ❌ #{inspect(reason)}")
  end
end)
```

## Chapter 5: SnmpKit.Sim - Device Simulation 🧪

One of SnmpKit's most unique features is comprehensive device simulation. Let's explore the simulation capabilities!

### Creating Device Populations

```elixir
IO.puts("=== Device Population Simulation ===\n")

# Create a population of different device types
device_configs = [
  %{type: :cable_modem, port: 2001, community: "public"},
  %{type: :cable_modem, port: 2002, community: "public"},
  %{type: :switch, port: 2003, community: "private"},
  %{type: :router, port: 2004, community: "public"}
]

{:ok, device_population} = Sim.start_device_population(device_configs)
IO.puts("Started #{length(device_population)} simulated devices")

# Test the population
population_targets = [
  "127.0.0.1:2001",
  "127.0.0.1:2002",
  "127.0.0.1:2003",
  "127.0.0.1:2004"
]

IO.puts("\nTesting device population:")
Enum.each(population_targets, fn target ->
  case SNMP.get(target, "sysDescr.0", timeout: 1000) do
    {:ok, description} ->
      IO.puts("  ✅ #{target}: #{description}")
    {:error, reason} ->
      IO.puts("  ❌ #{target}: #{inspect(reason)}")
  end
end)
```

### Simulation with Real Device Data

Our simulations can load real device walk files for authentic behavior:

```elixir
IO.puts("\n=== Real Device Data Simulation ===\n")

# The simulated devices are loaded from actual SNMP walks
# This means they respond with realistic data and OID trees

# Let's explore what's available on our cable modem
{:ok, cable_modem_system} = SNMP.walk(cable_modem_target, "system")
IO.puts("Cable modem system group has #{length(cable_modem_system)} objects")

# Look for DOCSIS-specific OIDs (cable modem technology)
docsis_tests = [
  "1.3.6.1.2.1.10.127.1.1.1.1.6.2",  # docsIfDownChannelPower
  "1.3.6.1.2.1.10.127.1.1.4.1.5.2",  # docsIfSigQSignalNoise
  "1.3.6.1.2.1.10.127.1.2.2.1.3.2"   # docsIfCmtsCmStatusValue
]

IO.puts("\nDOCSIS-specific objects:")
Enum.each(docsis_tests, fn oid ->
  case SNMP.get(cable_modem_target, oid) do
    {:ok, value} ->
      IO.puts("  ✅ #{oid}: #{value}")
    {:error, reason} ->
      IO.puts("  ❌ #{oid}: #{inspect(reason)}")
  end
end)
```

## Chapter 6: Direct Access API 🎯

For convenience, SnmpKit provides direct access to common operations without module prefixes:

```elixir
IO.puts("=== Direct Access API ===\n")

# These functions are available directly on SnmpKit
{:ok, direct_desc} = SnmpKit.get(cable_modem_target, "sysDescr.0")
IO.puts("Direct get: #{direct_desc}")

{:ok, direct_oid} = SnmpKit.resolve("sysUpTime.0")
IO.puts("Direct resolve: #{Enum.join(direct_oid, ".")}")

{:ok, direct_walk} = SnmpKit.walk(cable_modem_target, "system")
IO.puts("Direct walk: #{length(direct_walk)} objects")

# These are equivalent to their module-prefixed versions
{:ok, module_desc} = SNMP.get(cable_modem_target, "sysDescr.0")
{:ok, module_oid} = MIB.resolve("sysUpTime.0")

IO.puts("\nConsistency check:")
IO.puts("  Direct vs Module get: #{direct_desc == module_desc}")
IO.puts("  Direct vs Module resolve: #{direct_oid == module_oid}")
```

## Chapter 7: Real-World Monitoring Scenarios 🌐

Let's put it all together with some realistic network monitoring scenarios:

### Scenario 1: Interface Monitoring

```elixir
IO.puts("=== Scenario 1: Interface Monitoring ===\n")

# Monitor all interfaces on both devices
devices = [
  {cable_modem_target, "Cable Modem"},
  {router_target, "Router"}
]

Enum.each(devices, fn {target, name} ->
  IO.puts("#{name} (#{target}):")

  # Get interface count
  case SNMP.get(target, "ifNumber.0") do
    {:ok, if_count} ->
      IO.puts("  Interfaces: #{if_count}")

      # Get interface details for first interface
      case SNMP.get(target, "ifDescr.1") do
        {:ok, if_desc} ->
          IO.puts("  Interface 1: #{if_desc}")

          # Get traffic counters
          case SNMP.get(target, "ifInOctets.1") do
            {:ok, in_octets} ->
              IO.puts("  Bytes In: #{in_octets}")
            _ -> nil
          end

          case SNMP.get(target, "ifOutOctets.1") do
            {:ok, out_octets} ->
              IO.puts("  Bytes Out: #{out_octets}")
            _ -> nil
          end
        _ -> nil
      end
    _ ->
      IO.puts("  Unable to query interfaces")
  end

  IO.puts("")
end)
```

### Scenario 2: System Health Check

```elixir
IO.puts("=== Scenario 2: System Health Check ===\n")

# Define health check objects
health_checks = [
  {"sysDescr.0", "System Description"},
  {"sysUpTime.0", "Uptime"},
  {"sysContact.0", "Contact"},
  {"sysLocation.0", "Location"}
]

# Check both devices
Enum.each(devices, fn {target, name} ->
  IO.puts("Health check for #{name}:")

  Enum.each(health_checks, fn {oid, description} ->
    case SNMP.get(target, oid) do
      {:ok, value} ->
        formatted_value = if oid == "sysUpTime.0" do
          case SNMP.get_pretty(target, oid) do
            {:ok, pretty} -> pretty
            _ -> value
          end
        else
          value
        end
        IO.puts("  ✅ #{description}: #{formatted_value}")
      {:error, reason} ->
        IO.puts("  ❌ #{description}: #{inspect(reason)}")
    end
  end)

  IO.puts("")
end)
```

### Scenario 3: Bulk Data Collection

```elixir
IO.puts("=== Scenario 3: Bulk Data Collection ===\n")

# Efficiently collect large amounts of data
collection_targets = [
  {cable_modem_target, "interfaces", "Interface data"},
  {router_target, "system", "System data"}
]

Enum.each(collection_targets, fn {target, oid_group, description} ->
  IO.puts("Collecting #{description} from #{target}...")

  start_time = System.monotonic_time(:millisecond)

  case SNMP.bulk_walk(target, oid_group) do
    {:ok, results} ->
      end_time = System.monotonic_time(:millisecond)
      duration = end_time - start_time

      IO.puts("  ✅ Collected #{length(results)} objects in #{duration}ms")
      IO.puts("  Rate: #{Float.round(length(results) / duration * 1000, 1)} objects/second")
    {:error, reason} ->
      IO.puts("  ❌ Collection failed: #{inspect(reason)}")
  end
end)
```

## Chapter 8: Error Handling and Troubleshooting 🔧

Real-world SNMP operations need robust error handling. Let's explore SnmpKit's error handling capabilities:

```elixir
IO.puts("=== Error Handling Examples ===\n")

# Test various error conditions
error_tests = [
  {"Invalid host", "192.0.2.1", "sysDescr.0"},  # RFC 5737 test address
  {"Invalid OID", cable_modem_target, "1.1.1.1.1.1.1.999"},
  {"Timeout", cable_modem_target, "sysDescr.0"},  # With very short timeout
  {"Invalid community", cable_modem_target, "sysDescr.0"}  # Wrong community
]

Enum.each(error_tests, fn {test_name, target, oid} ->
  IO.puts("Testing: #{test_name}")

  opts = case test_name do
    "Timeout" -> [timeout: 1]  # Very short timeout
    "Invalid community" -> [community: "wrong"]
    _ -> []
  end

  case SNMP.get(target, oid, opts) do
    {:ok, value} ->
      IO.puts("  Unexpected success: #{value}")
    {:error, :timeout} ->
      IO.puts("  ✅ Timeout handled correctly")
    {:error, {:network_error, reason}} ->
      IO.puts("  ✅ Network error handled: #{reason}")
    {:error, reason} ->
      IO.puts("  ✅ Error handled: #{inspect(reason)}")
  end
end)
```

## Chapter 9: Performance Tips and Best Practices 📈

Let's explore performance optimization and best practices:

```elixir
IO.puts("=== Performance Best Practices ===\n")

# 1. Use bulk operations for multiple values
IO.puts("1. Bulk vs Individual Operations:")

# Time individual gets
start_time = System.monotonic_time(:microsecond)
individual_results = Enum.map(1..5, fn i ->
  SNMP.get(cable_modem_target, "ifDescr.#{i}")
end)
individual_time = System.monotonic_time(:microsecond) - start_time

# Time bulk operation
start_time = System.monotonic_time(:microsecond)
{:ok, bulk_results} = SNMP.bulk_walk(cable_modem_target, "ifDescr")
bulk_time = System.monotonic_time(:microsecond) - start_time

IO.puts("  Individual gets: #{individual_time}μs")
IO.puts("  Bulk operation: #{bulk_time}μs")
if bulk_time < individual_time do
  IO.puts("  ✅ Bulk is #{Float.round(individual_time / bulk_time, 1)}x faster")
else
  IO.puts("  Individual operations were faster (small dataset)")
end

# 2. Use multi-target for multiple devices
IO.puts("\n2. Multi-target Operations:")
multi_start = System.monotonic_time(:microsecond)
{:ok, _multi_results} = SNMP.get_multi([
  {cable_modem_target, "sysDescr.0"},
  {router_target, "sysDescr.0"}
])
multi_time = System.monotonic_time(:microsecond) - multi_start
IO.puts("  Multi-target time: #{multi_time}μs")

# 3. Use appropriate timeouts
IO.puts("\n3. Timeout Configuration:")
timeout_tests = [1000, 2000, 5000]
Enum.each(timeout_tests, fn timeout ->
  start_time = System.monotonic_time(:millisecond)
  case SNMP.get(cable_modem_target, "sysDescr.0", timeout: timeout) do
    {:ok, _} ->
      actual_time = System.monotonic_time(:millisecond) - start_time
      IO.puts("  Timeout #{timeout}ms: completed in #{actual_time}ms")
    {:error, :timeout} ->
      IO.puts("  Timeout #{timeout}ms: timed out")
  end
end)
```

## Chapter 10: Testing with Simulated Devices 🧪

Perfect for development and CI/CD pipelines:

```elixir
IO.puts("=== Testing Strategies ===\n")

# Example test function
defmodule NetworkMonitorTest do
  def test_device_monitoring(target) do
    # Test basic connectivity
    with {:ok, _desc} <- SNMP.get(target, "sysDescr.0"),
         {:ok, _uptime} <- SNMP.get(target, "sysUpTime.0"),
         {:ok, interfaces} <- SNMP.walk(target, "interfaces") do
      %{
        status: :healthy,
        interface_count: length(interfaces),
        timestamp: DateTime.utc_now()
      }
    else
      {:error, reason} ->
        %{
          status: :error,
          reason: reason,
          timestamp: DateTime.utc_now()
        }
    end
  end
end

# Test against our simulated devices
test_targets = [cable_modem_target, router_target]

IO.puts("Running tests against simulated devices:")
Enum.each(test_targets, fn target ->
  result = NetworkMonitorTest.test_device_monitoring(target)
  case result.status do
    :healthy ->
